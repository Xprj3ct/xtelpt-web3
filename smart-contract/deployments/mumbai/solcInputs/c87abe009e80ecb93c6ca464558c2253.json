{
  "language": "Solidity",
  "sources": {
    "contracts/XTELPT.sol": {
      "content": "/**\r\n *Submitted for verification at polygonscan.com on 2022-11-12\r\n*/\r\n\r\n/**\r\n *Submitted for verification at polygonscan.com on 2022-11-04\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\n// import \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\";\r\n\r\ncontract XTELPT  {\r\n    address public owner;\r\n\r\n    enum XTELPState {\r\n        OPEN,\r\n        CLOSED\r\n    }\r\n\r\n    uint public counter;    \r\n    // Use an interval in seconds and a timestamp to slow execution of Upkeep\r\n    uint public immutable interval;\r\n    uint public lastTimeStamp;\r\n\r\n    /* string User Types */\r\n    string userType = \"User\";\r\n    string hostType = \"Host\";\r\n    string volunType = \"Volun\";\r\n\r\n\r\n    /* Campaign and Meeting variables */\r\n    mapping(address => meeting[]) public Meeting;\r\n\r\n    campaign [] public Campaign;\r\n\r\n    uint256 public campaignIndex;\r\n    \r\n    uint256 public meetingIndex;    \r\n    \r\n    /* User profile mapping */\r\n    mapping(address => profile) public UserProfile;\r\n\r\n    /* State mapping */\r\n    mapping(address => XTELPState) private s_xtelpState;\r\n    mapping(address => XTELPState) private volunState;\r\n\r\n    /* User Types Arrays */\r\n    address [] public AllAccount;\r\n\r\n    address [] public recentCampaignCreator;\r\n\r\n\r\n    /* Struct */\r\n    struct profile {\r\n        address addr;\r\n        string name;\r\n        string role;\r\n        uint256 rating;\r\n        string bio;\r\n        string profilePic;\r\n        string hostTitle;\r\n    }\r\n\r\n    struct meeting {\r\n        address payable host;\r\n        address payable user;\r\n        uint256 start;\r\n        uint256 end;\r\n        string desc;\r\n        uint256 time;\r\n        uint256 fee;\r\n        uint256 index;\r\n        bool completed;\r\n        bool booked;\r\n    }\r\n\r\n\r\n    struct campaign {\r\n        address [] volunteer;\r\n        address user;\r\n        address vol;\r\n        uint256 start_time;\r\n        uint256 end_time;\r\n        string image;\r\n        uint256 fee;\r\n        uint256 index;\r\n        bool completed;\r\n        string name;\r\n        string desc;\r\n    }\r\n\r\n    /* Modifiers */\r\n    modifier onlyOwner  {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n   \r\n    modifier onlyHost  {\r\n        require(keccak256(abi.encodePacked(UserProfile[msg.sender].role)) == keccak256(abi.encodePacked(\"Host\")), \"NOT A HOST\");\r\n        _;\r\n    }\r\n   \r\n\r\n    modifier onlyUser  {\r\n        require(keccak256(abi.encodePacked(UserProfile[msg.sender].role)) == keccak256(abi.encodePacked(\"User\")), \"NOT A USER\");\r\n        _;\r\n    }\r\n\r\n    event RequestedID(uint256 indexed requestId);\r\n\r\n    /**\r\n     * @dev constructor used to assign values that will not change\r\n     */\r\n    constructor() {\r\n        owner =  msg.sender;\r\n      \r\n        lastTimeStamp = block.timestamp;\r\n        s_xtelpState[msg.sender] = XTELPState.OPEN;\r\n        volunState[msg.sender] = XTELPState.OPEN;\r\n        interval = 300;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev This function `createUser` any body can call this functions and the senders profile\r\n     * would be set to that of a `User`\r\n     */\r\n    function createUser(uint256 _rating, string memory _name, string memory _pic, string memory _bio) public {\r\n         if(UserProfile[msg.sender].addr == address(0)){\r\n            AllAccount.push(msg.sender);\r\n        }\r\n        \r\n        UserProfile[msg.sender].addr = msg.sender;\r\n        UserProfile[msg.sender].name = _name;\r\n        UserProfile[msg.sender].rating = _rating;\r\n        UserProfile[msg.sender].role = userType;\r\n        UserProfile[msg.sender].profilePic = _pic;\r\n        UserProfile[msg.sender].bio = _bio;\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev This function `createHost` any body can call this functions and the senders profile\r\n     * would be set to that of a `Host`\r\n     */\r\n    function createHost(uint256 _rating, string memory _name, string memory _pic, string memory _bio, string memory _title) public {  \r\n        if(UserProfile[msg.sender].addr == address(0)){\r\n            AllAccount.push(msg.sender);\r\n        }\r\n        \r\n        s_xtelpState[msg.sender] = XTELPState.OPEN;\r\n\r\n        UserProfile[msg.sender].addr = msg.sender;\r\n        UserProfile[msg.sender].name = _name;\r\n        UserProfile[msg.sender].hostTitle = _title;\r\n        UserProfile[msg.sender].rating = _rating;\r\n        UserProfile[msg.sender].role = hostType;\r\n        UserProfile[msg.sender].profilePic = _pic;\r\n        UserProfile[msg.sender].bio = _bio;\r\n    }\r\n\r\n   \r\n    /**\r\n     * @dev This function `createSchedule` allows only the Host to call it hence the `OnlyHost` modifier\r\n     * after which a Host can create a meeting with some parameters like time and fee needed\r\n     */\r\n    function createSchedule(uint256 _start, uint256 _end, uint256 _fee, string memory _desc) public onlyHost {\r\n       \r\n        meeting memory NewMeeting;\r\n        NewMeeting.host = payable(msg.sender);\r\n        NewMeeting.end = _end;\r\n        NewMeeting.desc = _desc;\r\n        NewMeeting.start = _start;\r\n        NewMeeting.index =  meetingIndex;\r\n        NewMeeting.fee = _fee;\r\n\r\n        s_xtelpState[msg.sender] = XTELPState.OPEN;\r\n        Meeting[msg.sender].push(NewMeeting);\r\n        meetingIndex ++;\r\n    }\r\n\r\n    /**\r\n     * @dev This function `joinMeeting` allows only the User to call it hence the `OnlyUser` modifier\r\n     * after which the meeting ID is specified and the user would be assigned to the meeting\r\n     */\r\n    function joinMeeting(address _host, uint256 _id) public payable onlyUser {\r\n        Meeting[_host][_id].user = payable(msg.sender);\r\n        Meeting[_host][_id].booked = true;\r\n    } \r\n\r\n    /**\r\n     * @dev This function `createCampaign` allows only the User to call it hence the `OnlyUser` modifier\r\n     * after which any avaliable volunteer would be assigned to the campaign\r\n     */\r\n    function createCampaign(string memory _name, string memory _desc, string memory _image) public onlyOwner {\r\n        \r\n        campaign memory NewCampaign;\r\n        NewCampaign.start_time = block.timestamp;\r\n        NewCampaign.name = _name;\r\n        NewCampaign.image = _image;\r\n        NewCampaign.index = campaignIndex;\r\n        NewCampaign.desc = _desc;\r\n        NewCampaign.fee = 0;\r\n\r\n        s_xtelpState[msg.sender] = XTELPState.OPEN;\r\n\r\n        Campaign.push(NewCampaign);\r\n        \r\n        campaignIndex ++;\r\n      \r\n    }\r\n\r\n    /**\r\n     * @dev This function `getHelp` allows only the User to call it hence the `OnlyUser` modifier\r\n     * after which the Campaign ID is specified and the user would be assigned to the Campaign\r\n     */\r\n    function getHelp(uint256 _id) public onlyUser {\r\n        Campaign[_id].user = msg.sender;\r\n        Campaign[_id].vol = Campaign[_id].volunteer[Campaign[_id].volunteer.length - 1];\r\n    } \r\n\r\n    /**\r\n     * @dev This function `joinCampaign` allows only the User to call it hence the `onlyHost` modifier\r\n     * after which the Campaign ID is specified and the user would be assigned to the Campaign\r\n     */\r\n    function joinCampaign(uint256 _id) public onlyHost {\r\n        Campaign[_id].volunteer.push(msg.sender);\r\n    } \r\n    \r\n    /**\r\n     * @dev This function `endCampaign` allows only the User end the campaign\r\n     */\r\n    function endCampaign(uint256 _id) public onlyUser {\r\n       Campaign[_id].completed = true;\r\n       Campaign[_id].end_time = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev This function `endMeeting` is called by chainlink automation cron job and ends every meeting by setting the completed status to true\r\n     */\r\n    function endMeeting() public {\r\n         for (uint i = 0; i < AllAccount.length; i++) {\r\n            for (uint j = 0; j < Meeting[AllAccount[i]].length; j++) { \r\n                Meeting[AllAccount[i]][j].completed = true;\r\n                lastTimeStamp = block.timestamp;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev This function `editCampaign` can only be called by the owner of the smart contract to make changes to th campaign that is still active\r\n     */\r\n    function editCampaign(uint256 _id, string memory _name, string memory _desc, string memory _image) public onlyOwner {\r\n        Campaign[_id].name = _name;\r\n        Campaign[_id].image = _image;\r\n        Campaign[_id].desc = _desc;\r\n    }\r\n   \r\n   \r\n    /** Getter Functions */\r\n\r\n    function meetingNum() public view returns (uint256) {\r\n        return meetingIndex;\r\n    }\r\n    \r\n    function campaignNum() public view returns (uint256) {\r\n        return campaignIndex;\r\n    }\r\n\r\n    function getMeeting(address _prof) public view returns (meeting [] memory) {\r\n        return Meeting[_prof];\r\n    }\r\n      \r\n\r\n    function getProfile(address userAdd) public view returns (profile memory) {\r\n        return UserProfile[userAdd];\r\n    }\r\n\r\n    function getAllAccount() public view returns (address [] memory) {\r\n        return AllAccount;\r\n    }\r\n\r\n    function getCampaign() public view returns (campaign [] memory) {\r\n        return Campaign;\r\n    }\r\n    \r\n   \r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}