{
  "language": "Solidity",
  "sources": {
    "contracts/XTELPT.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n// import \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\r\n// import \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\r\n// import \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\";\r\n// import \"hardhat/console.sol\";\r\n\r\n\r\ninterface VRFCoordinatorV2Interface {\r\n  /**\r\n   * @notice Get configuration relevant for making requests\r\n   * @return minimumRequestConfirmations global min for request confirmations\r\n   * @return maxGasLimit global max for request gas limit\r\n   * @return s_provingKeyHashes list of registered key hashes\r\n   */\r\n  function getRequestConfig()\r\n    external\r\n    view\r\n    returns (\r\n      uint16,\r\n      uint32,\r\n      bytes32[] memory\r\n    );\r\n\r\n  /**\r\n   * @notice Request a set of random words.\r\n   * @param keyHash - Corresponds to a particular oracle job which uses\r\n   * that key for generating the VRF proof. Different keyHash's have different gas price\r\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\r\n   * @param subId  - The ID of the VRF subscription. Must be funded\r\n   * with the minimum subscription balance required for the selected keyHash.\r\n   * @param minimumRequestConfirmations - How many blocks you'd like the\r\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\r\n   * for why you may want to request more. The acceptable range is\r\n   * [minimumRequestBlockConfirmations, 200].\r\n   * @param callbackGasLimit - How much gas you'd like to receive in your\r\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\r\n   * may be slightly less than this amount because of gas used calling the function\r\n   * (argument decoding etc.), so you may need to request slightly more than you expect\r\n   * to have inside fulfillRandomWords. The acceptable range is\r\n   * [0, maxGasLimit]\r\n   * @param numWords - The number of uint256 random values you'd like to receive\r\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\r\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\r\n   * @return requestId - A unique identifier of the request. Can be used to match\r\n   * a request to a response in fulfillRandomWords.\r\n   */\r\n  function requestRandomWords(\r\n    bytes32 keyHash,\r\n    uint64 subId,\r\n    uint16 minimumRequestConfirmations,\r\n    uint32 callbackGasLimit,\r\n    uint32 numWords\r\n  ) external returns (uint256 requestId);\r\n\r\n  /**\r\n   * @notice Create a VRF subscription.\r\n   * @return subId - A unique subscription id.\r\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\r\n   * @dev Note to fund the subscription, use transferAndCall. For example\r\n   * @dev  LINKTOKEN.transferAndCall(\r\n   * @dev    address(COORDINATOR),\r\n   * @dev    amount,\r\n   * @dev    abi.encode(subId));\r\n   */\r\n  function createSubscription() external returns (uint64 subId);\r\n\r\n  /**\r\n   * @notice Get a VRF subscription.\r\n   * @param subId - ID of the subscription\r\n   * @return balance - LINK balance of the subscription in juels.\r\n   * @return reqCount - number of requests for this subscription, determines fee tier.\r\n   * @return owner - owner of the subscription.\r\n   * @return consumers - list of consumer address which are able to use this subscription.\r\n   */\r\n  function getSubscription(uint64 subId)\r\n    external\r\n    view\r\n    returns (\r\n      uint96 balance,\r\n      uint64 reqCount,\r\n      address owner,\r\n      address[] memory consumers\r\n    );\r\n\r\n  /**\r\n   * @notice Request subscription owner transfer.\r\n   * @param subId - ID of the subscription\r\n   * @param newOwner - proposed new owner of the subscription\r\n   */\r\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\r\n\r\n  /**\r\n   * @notice Request subscription owner transfer.\r\n   * @param subId - ID of the subscription\r\n   * @dev will revert if original owner of subId has\r\n   * not requested that msg.sender become the new owner.\r\n   */\r\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\r\n\r\n  /**\r\n   * @notice Add a consumer to a VRF subscription.\r\n   * @param subId - ID of the subscription\r\n   * @param consumer - New consumer which can use the subscription\r\n   */\r\n  function addConsumer(uint64 subId, address consumer) external;\r\n\r\n  /**\r\n   * @notice Remove a consumer from a VRF subscription.\r\n   * @param subId - ID of the subscription\r\n   * @param consumer - Consumer to remove from the subscription\r\n   */\r\n  function removeConsumer(uint64 subId, address consumer) external;\r\n\r\n  /**\r\n   * @notice Cancel a subscription\r\n   * @param subId - ID of the subscription\r\n   * @param to - Where to send the remaining LINK to\r\n   */\r\n  function cancelSubscription(uint64 subId, address to) external;\r\n\r\n  /*\r\n   * @notice Check to see if there exists a request commitment consumers\r\n   * for all consumers and keyhashes for a given sub.\r\n   * @param subId - ID of the subscription\r\n   * @return true if there exists at least one unfulfilled request for the subscription, false\r\n   * otherwise.\r\n   */\r\n  function pendingRequestExists(uint64 subId) external view returns (bool);\r\n}\r\n\r\nabstract contract VRFConsumerBaseV2 {\r\n  error OnlyCoordinatorCanFulfill(address have, address want);\r\n  address private immutable vrfCoordinator;\r\n\r\n  constructor(address _vrfCoordinator) {\r\n    vrfCoordinator = _vrfCoordinator;\r\n  }\r\n\r\n  \r\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\r\n\r\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\r\n    if (msg.sender != vrfCoordinator) {\r\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\r\n    }\r\n    fulfillRandomWords(requestId, randomWords);\r\n  }\r\n}\r\n\r\ninterface KeeperCompatibleInterface {\r\n    function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\r\n    function performUpkeep(bytes calldata performData) external;\r\n}\r\n\r\ncontract XTELPT is  KeeperCompatibleInterface {\r\n\r\n    enum XTELPState {\r\n        OPEN,\r\n        CLOSED\r\n    }\r\n\r\n    uint public counter;    \r\n    // Use an i_interval in seconds and a timestamp to slow execution of Upkeep\r\n    uint private i_interval;\r\n    uint public s_lastTimeStamp;\r\n    uint public v_lastTimeStamp;\r\n\r\n\r\n    /* string User Types */\r\n    string userType = \"User\";\r\n    string hostType = \"Host\";\r\n    string volunType = \"Volun\";\r\n\r\n\r\n    /* Campaign and Meeting variables */\r\n\r\n    mapping(address => campaign[]) public Campaign;\r\n\r\n    mapping(address => meeting[]) public Meeting;\r\n\r\n    uint256 public campaignIndex;\r\n    \r\n    uint256 public meetingIndex;    \r\n    \r\n    /* User profile mapping */\r\n    mapping(address => profile) public UserProfile;\r\n\r\n    /* State mapping */\r\n    mapping(address => XTELPState) private s_xtelpState;\r\n    mapping(address => XTELPState) private volunState;\r\n\r\n    /* User Types Arrays */\r\n    address [] public AllHost;\r\n\r\n    address [] public AllVolun;\r\n    \r\n    address [] public AllUser;\r\n\r\n    address [] public recentCampaignCreator;\r\n\r\n\r\n    /* Struct */\r\n    struct profile {\r\n        address addr;\r\n        string name;\r\n        string role;\r\n        uint256 rating;\r\n        string bio;\r\n        string profilePic;\r\n        bool avaliable;\r\n        bool volun;\r\n    }\r\n\r\n    struct meeting {\r\n        address host;\r\n        address user;\r\n        uint256 time;\r\n        uint256 fee;\r\n        bool completed;\r\n    }\r\n    \r\n    struct campaign {\r\n        address volunteer;\r\n        address user;\r\n        uint256 time;\r\n        uint256 fee;\r\n        bool completed;\r\n    }\r\n\r\n    /* Modifiers */\r\n    modifier onlyHost  {\r\n        require(keccak256(abi.encodePacked(UserProfile[msg.sender].role)) == keccak256(abi.encodePacked(\"Host\")), \"NOT A HOST\");\r\n        _;\r\n    }\r\n   \r\n    modifier onlyVolun  {\r\n        require(keccak256(abi.encodePacked(UserProfile[msg.sender].role)) == keccak256(abi.encodePacked(\"Host\")) && UserProfile[msg.sender].avaliable == true , \"NOT A VOLUNTEER\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyUser  {\r\n        require(keccak256(abi.encodePacked(UserProfile[msg.sender].role)) == keccak256(abi.encodePacked(\"User\")), \"NOT A USER\");\r\n        _;\r\n    }\r\n\r\n    event RequestedID(uint256 indexed requestId);\r\n\r\n    \r\n    constructor() {\r\n      \r\n        s_lastTimeStamp = block.timestamp;\r\n        v_lastTimeStamp = block.timestamp;\r\n        s_xtelpState[msg.sender] = XTELPState.OPEN;\r\n        volunState[msg.sender] = XTELPState.OPEN;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev This function `createUser` any body can call this functions and the senders profile\r\n     * would be set to that of a `User`\r\n     */\r\n    function createUser(uint256 _rating, string memory _name, string memory _pic, string memory _bio) public {\r\n        AllUser.push(msg.sender);\r\n        UserProfile[msg.sender].addr = msg.sender;\r\n        UserProfile[msg.sender].name = _name;\r\n        UserProfile[msg.sender].rating = _rating;\r\n        UserProfile[msg.sender].role = userType;\r\n        UserProfile[msg.sender].profilePic = _pic;\r\n        UserProfile[msg.sender].bio = _bio;\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev This function `createHost` any body can call this functions and the senders profile\r\n     * would be set to that of a `Host`\r\n     */\r\n    function createHost(uint256 _rating, string memory _name, string memory _pic, string memory _bio) public {  \r\n        AllHost.push(msg.sender);\r\n        s_xtelpState[msg.sender] = XTELPState.OPEN;\r\n\r\n        UserProfile[msg.sender].addr = msg.sender;\r\n        UserProfile[msg.sender].name = _name;\r\n        UserProfile[msg.sender].rating = _rating;\r\n        UserProfile[msg.sender].role = hostType;\r\n        UserProfile[msg.sender].profilePic = _pic;\r\n        UserProfile[msg.sender].bio = _bio;\r\n    }\r\n\r\n     /**\r\n     * @dev This function `createVolun` allows only the Host to call it hence the `OnlyHost` modifier\r\n     * A host can toggle being a volunteer for campaign mode on, thereby making the profile avaliable for campaign \r\n     */\r\n    function becomeVolun() public onlyHost {\r\n        AllVolun.push(msg.sender);\r\n       \r\n        UserProfile[msg.sender].volun = true;\r\n        UserProfile[msg.sender].avaliable = true;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev This function `unVolun` allows only the Host to call it hence the `OnlyHost` modifier\r\n     * A host can toggle being a volunteer for campaign mode off, thereby making the profile unavaliable for campaign \r\n     */\r\n    function unVolun() public onlyHost {\r\n        // AllVolun.push(msg.sender);\r\n       \r\n        UserProfile[msg.sender].volun = false;\r\n        UserProfile[msg.sender].avaliable = false;\r\n\r\n    }\r\n\r\n    // Schedule a meeting\r\n    function createSchedule(uint256 _time, uint256 _fee) public onlyHost {\r\n        meetingIndex ++;\r\n        \r\n        meeting memory NewMeeting;\r\n        NewMeeting.host = msg.sender;\r\n        NewMeeting.time = _time;\r\n        NewMeeting.fee = _fee;\r\n\r\n        i_interval = _time;\r\n        s_xtelpState[msg.sender] = XTELPState.OPEN;\r\n\r\n        Meeting[msg.sender].push(NewMeeting);\r\n      \r\n    }\r\n\r\n    // Join Meeting\r\n    function joinMeeting(address _host, uint256 _id) public onlyUser {\r\n        Meeting[_host][_id].user = msg.sender;\r\n    } \r\n\r\n    /**\r\n     * @dev This function `createCampaign` allows only the User to call it hence the `OnlyUser` modifier\r\n     * after which any avaliable volunteer would be assigned to the campaign\r\n     */\r\n    function createCampaign() public onlyUser {\r\n        campaignIndex ++;\r\n\r\n        campaign memory NewCampaign;\r\n        NewCampaign.user = msg.sender;\r\n        NewCampaign.time = 1;\r\n        NewCampaign.fee = 0;\r\n\r\n        i_interval = 1;\r\n        s_xtelpState[msg.sender] = XTELPState.OPEN;\r\n\r\n        for(uint i = 0; i < AllVolun.length; i++){\r\n            if(UserProfile[AllVolun[i]].avaliable == true){\r\n                NewCampaign.volunteer = AllVolun[i];\r\n                UserProfile[AllVolun[i]].avaliable = false;\r\n                break;\r\n            }\r\n        }\r\n\r\n        Campaign[msg.sender].push(NewCampaign);\r\n      \r\n    }\r\n\r\n\r\n      \r\n\r\n\r\n    /**\r\n     * @dev This is the function that the Chainlink Keeper nodes call\r\n     * they look for `upkeepNeeded` to return True.\r\n     * the following should be true for this to return true:\r\n     * 1. It makes sure that the campaign or meeting is not yet completed\r\n     * 2. The time interval has passed for either meeting or campaign.\r\n     */\r\n    function checkUpkeep(bytes memory checkData) public view override returns ( bool upkeepNeeded,\r\n        bytes memory  performData   ) {\r\n        if(AllHost.length > 0){\r\n            for (uint i = 0; i < AllHost.length; i++) {\r\n                for (uint j = 0; j < Meeting[AllHost[i]].length; j++) {\r\n                    if(Meeting[AllHost[i]][j].time > 0 && Meeting[AllHost[i]][j].completed == false){\r\n                        bool isOpen = XTELPState.OPEN == s_xtelpState[msg.sender];\r\n                        bool timePassed = ((block.timestamp - s_lastTimeStamp) >  Meeting[AllHost[i]][j].time);\r\n                        upkeepNeeded = (isOpen && timePassed);\r\n                        performData = abi.encodePacked(uint256(0)); // This is the new line\r\n                        return (true, performData) ;\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        } if (AllUser.length > 0) {      \r\n\r\n            for (uint i = 0; i < AllUser.length; i++) {\r\n                for (uint j = 0; j < Campaign[AllUser[i]].length; j++) {\r\n                    if(Campaign[AllUser[i]][j].time > 0 && Campaign[AllUser[i]][j].completed == false){\r\n                        bool isOpen = XTELPState.OPEN == volunState[msg.sender];\r\n                        bool timePassed = ((block.timestamp - v_lastTimeStamp) >  Campaign[AllUser[i]][j].time);\r\n                        upkeepNeeded = (isOpen && timePassed);\r\n                        performData = abi.encodePacked(uint256(1)); // This is the new line\r\n                        return (true, performData) ;\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        }\r\n       \r\n    }\r\n\r\n    /**\r\n     * @dev Once `checkUpkeep` is returning `true`, this function is called\r\n     */\r\n    function performUpkeep( bytes calldata performData) external override{\r\n        uint256 decodedValue = abi.decode(performData, (uint256));\r\n        if(decodedValue == 0){\r\n            for (uint i = 0; i < AllHost.length; i++) {\r\n                for (uint j = 0; j < Meeting[AllHost[i]].length; j++) {\r\n                (bool upkeepNeeded, ) = checkUpkeep(\"\");\r\n                    require(upkeepNeeded, \"Doesn't meet requirement for UpKeep\");\r\n                    Meeting[AllHost[i]][j].completed = true;\r\n                    s_xtelpState[AllHost[i]] = XTELPState.CLOSED;\r\n                }\r\n            }  \r\n        } if (decodedValue == 1) {\r\n            for (uint i = 0; i < AllUser.length; i++) {\r\n            for (uint j = 0; j < Campaign[AllUser[i]].length; j++) {\r\n               (bool upkeepNeeded, ) = checkUpkeep(\"\");\r\n                require(upkeepNeeded, \"Doesn't meet requirement for UpKeep\");\r\n                Campaign[AllUser[i]][j].completed = true;\r\n                volunState[AllUser[i]] = XTELPState.CLOSED;\r\n            }\r\n        }   \r\n        }\r\n\r\n               \r\n    }\r\n   \r\n   \r\n    /** Getter Functions */\r\n\r\n    function meetingNum() public view returns (uint256) {\r\n        return meetingIndex;\r\n    }\r\n    \r\n    function campaignNum() public view returns (uint256) {\r\n        return campaignIndex;\r\n    }\r\n\r\n    function getMeeting(address _prof) public view returns (meeting [] memory) {\r\n        return Meeting[_prof];\r\n    }\r\n    \r\n    function getCampaign(address _prof) public view returns (campaign [] memory) {\r\n        return Campaign[_prof];\r\n    }\r\n    \r\n\r\n    function getProfile(address userAdd) public view returns (profile memory) {\r\n        return UserProfile[userAdd];\r\n    }\r\n\r\n    function getAllHost() public view returns (address [] memory) {\r\n        return AllHost;\r\n    }\r\n    \r\n    function getAllUser() public view returns (address [] memory) {\r\n        return AllUser;\r\n    }\r\n    \r\n    function getAllVolun() public view returns (address [] memory) {\r\n        return AllVolun;\r\n    }\r\n\r\n   \r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}