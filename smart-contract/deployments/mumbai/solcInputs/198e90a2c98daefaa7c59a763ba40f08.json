{
  "language": "Solidity",
  "sources": {
    "contracts/XTELPT.sol": {
      "content": "/**\r\n *Submitted for verification at polygonscan.com on 2022-11-04\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n// import \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\";\r\n\r\ninterface KeeperCompatibleInterface {\r\n    function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\r\n    function performUpkeep(bytes calldata performData) external;\r\n}\r\n\r\ncontract XTELPT is  KeeperCompatibleInterface {\r\n    address owner;\r\n\r\n    enum XTELPState {\r\n        OPEN,\r\n        CLOSED\r\n    }\r\n\r\n    uint public counter;    \r\n    // Use an i_interval in seconds and a timestamp to slow execution of Upkeep\r\n    uint private i_interval;\r\n    uint public s_lastTimeStamp;\r\n    uint public v_lastTimeStamp;\r\n\r\n\r\n    /* string User Types */\r\n    string userType = \"User\";\r\n    string hostType = \"Host\";\r\n    string volunType = \"Volun\";\r\n\r\n\r\n    /* Campaign and Meeting variables */\r\n\r\n    mapping(address => meeting[]) public Meeting;\r\n\r\n    campaign [] public Campaign;\r\n\r\n\r\n    uint256 public campaignIndex;\r\n    \r\n    uint256 public meetingIndex;    \r\n    \r\n    /* User profile mapping */\r\n    mapping(address => profile) public UserProfile;\r\n\r\n    /* State mapping */\r\n    mapping(address => XTELPState) private s_xtelpState;\r\n    mapping(address => XTELPState) private volunState;\r\n\r\n    /* User Types Arrays */\r\n    address [] public AllAccount;\r\n\r\n    address [] public recentCampaignCreator;\r\n\r\n\r\n    /* Struct */\r\n    struct profile {\r\n        address addr;\r\n        string name;\r\n        string role;\r\n        uint256 rating;\r\n        string bio;\r\n        string profilePic;\r\n        bool avaliable;\r\n        bool volun;\r\n    }\r\n\r\n    struct meeting {\r\n        address host;\r\n        address user;\r\n        uint256 start;\r\n        uint256 end;\r\n        uint256 time;\r\n        uint256 fee;\r\n        uint256 index;\r\n        bool completed;\r\n    }\r\n\r\n\r\n    struct campaign {\r\n        address [] volunteer;\r\n        address user;\r\n        uint256 start_time;\r\n        uint256 end_time;\r\n        uint256 fee;\r\n        uint256 index;\r\n        bool completed;\r\n        string name;\r\n        string desc;\r\n    }\r\n\r\n    /* Modifiers */\r\n    modifier onlyOwner  {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n   \r\n    modifier onlyHost  {\r\n        require(keccak256(abi.encodePacked(UserProfile[msg.sender].role)) == keccak256(abi.encodePacked(\"Host\")), \"NOT A HOST\");\r\n        _;\r\n    }\r\n   \r\n    modifier onlyVolun  {\r\n        require(keccak256(abi.encodePacked(UserProfile[msg.sender].role)) == keccak256(abi.encodePacked(\"Host\")) && UserProfile[msg.sender].avaliable == true , \"NOT A VOLUNTEER\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyUser  {\r\n        require(keccak256(abi.encodePacked(UserProfile[msg.sender].role)) == keccak256(abi.encodePacked(\"User\")), \"NOT A USER\");\r\n        _;\r\n    }\r\n\r\n    event RequestedID(uint256 indexed requestId);\r\n\r\n    /**\r\n     * @dev constructor used to assign values that will not change\r\n     */\r\n    constructor() {\r\n      \r\n        s_lastTimeStamp = block.timestamp;\r\n        v_lastTimeStamp = block.timestamp;\r\n        s_xtelpState[msg.sender] = XTELPState.OPEN;\r\n        volunState[msg.sender] = XTELPState.OPEN;\r\n\r\n        owner =  msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev This function `createUser` any body can call this functions and the senders profile\r\n     * would be set to that of a `User`\r\n     */\r\n    function createUser(uint256 _rating, string memory _name, string memory _pic, string memory _bio) public {\r\n         if(UserProfile[msg.sender].addr == address(0)){\r\n            AllAccount.push(msg.sender);\r\n        }\r\n        \r\n        UserProfile[msg.sender].addr = msg.sender;\r\n        UserProfile[msg.sender].name = _name;\r\n        UserProfile[msg.sender].rating = _rating;\r\n        UserProfile[msg.sender].role = userType;\r\n        UserProfile[msg.sender].profilePic = _pic;\r\n        UserProfile[msg.sender].bio = _bio;\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev This function `createHost` any body can call this functions and the senders profile\r\n     * would be set to that of a `Host`\r\n     */\r\n    function createHost(uint256 _rating, string memory _name, string memory _pic, string memory _bio) public {  \r\n        if(UserProfile[msg.sender].addr == address(0)){\r\n            AllAccount.push(msg.sender);\r\n        }\r\n        \r\n        s_xtelpState[msg.sender] = XTELPState.OPEN;\r\n\r\n        UserProfile[msg.sender].addr = msg.sender;\r\n        UserProfile[msg.sender].name = _name;\r\n        UserProfile[msg.sender].rating = _rating;\r\n        UserProfile[msg.sender].role = hostType;\r\n        UserProfile[msg.sender].profilePic = _pic;\r\n        UserProfile[msg.sender].bio = _bio;\r\n    }\r\n\r\n     /**\r\n     * @dev This function `createVolun` allows only the Host to call it hence the `OnlyHost` modifier\r\n     * A host can toggle being a volunteer for campaign mode on, thereby making the profile avaliable for campaign \r\n     */\r\n     function becomeVolun() public onlyHost {\r\n       \r\n        UserProfile[msg.sender].volun = true;\r\n        UserProfile[msg.sender].avaliable = true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev This function `unVolun` allows only the Host to call it hence the `OnlyHost` modifier\r\n     * A host can toggle being a volunteer for campaign mode off, thereby making the profile unavaliable for campaign \r\n     */\r\n    function unVolun() public onlyHost {       \r\n        UserProfile[msg.sender].volun = false;\r\n        UserProfile[msg.sender].avaliable = false;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev This function `createSchedule` allows only the Host to call it hence the `OnlyHost` modifier\r\n     * after which a Host can create a meeting with some parameters like time and fee needed\r\n     */\r\n    function createSchedule(uint256 _time, uint256 _fee) public onlyHost {\r\n       \r\n\r\n        meeting memory NewMeeting;\r\n        NewMeeting.host = msg.sender;\r\n        NewMeeting.time = _time * 60;\r\n        NewMeeting.start = block.timestamp;\r\n        NewMeeting.index =  meetingIndex;\r\n        NewMeeting.fee = _fee;\r\n\r\n        i_interval = _time * 60;\r\n        s_xtelpState[msg.sender] = XTELPState.OPEN;\r\n\r\n        Meeting[msg.sender].push(NewMeeting);\r\n      \r\n        meetingIndex ++;\r\n    }\r\n\r\n    /**\r\n     * @dev This function `joinMeeting` allows only the User to call it hence the `OnlyUser` modifier\r\n     * after which the meeting ID is specified and the user would be assigned to the meeting\r\n     */\r\n    function joinMeeting(address _host, uint256 _id) public onlyUser {\r\n        Meeting[_host][_id].user = msg.sender;\r\n    } \r\n\r\n    /**\r\n     * @dev This function `createCampaign` allows only the User to call it hence the `OnlyUser` modifier\r\n     * after which any avaliable volunteer would be assigned to the campaign\r\n     */\r\n    function createCampaign(string memory _name, string memory _desc) public onlyOwner {\r\n        \r\n        campaign memory NewCampaign;\r\n        NewCampaign.start_time = block.timestamp;\r\n        NewCampaign.name = _name;\r\n        NewCampaign.index = campaignIndex;\r\n        NewCampaign.desc = _desc;\r\n        NewCampaign.fee = 0;\r\n\r\n        i_interval = 1;\r\n        s_xtelpState[msg.sender] = XTELPState.OPEN;\r\n\r\n        Campaign.push(NewCampaign);\r\n        \r\n        campaignIndex ++;\r\n      \r\n    }\r\n\r\n    /**\r\n     * @dev This function `getHelo` allows only the User to call it hence the `OnlyUser` modifier\r\n     * after which the Campaign ID is specified and the user would be assigned to the Campaign\r\n     */\r\n    function getHelp(uint256 _id) public onlyUser {\r\n        Campaign[_id].user = msg.sender;\r\n    } \r\n\r\n    /**\r\n     * @dev This function `joinCampaign` allows only the User to call it hence the `onlyHost` modifier\r\n     * after which the Campaign ID is specified and the user would be assigned to the Campaign\r\n     */\r\n    function joinCampaign(uint256 _id) public onlyVolun {\r\n        Campaign[_id].volunteer.push(msg.sender);\r\n    } \r\n    \r\n\r\n\r\n    /**\r\n     * @dev This function `endCampaign` allows only the User end the campaign\r\n     */\r\n    function endCampaign(uint256 _id) public onlyUser {\r\n       Campaign[_id].completed = true;\r\n       Campaign[_id].end_time = block.timestamp;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev This is the function that the Chainlink Keeper nodes call\r\n     * they look for `upkeepNeeded` to return True.\r\n     * the following should be true for this to return true:\r\n     * 1. It makes sure that the campaign or meeting is not yet completed\r\n     * 2. The time interval has passed for either meeting or campaign.\r\n     */\r\n   \r\n   function checkUpkeep(bytes memory /* checkData */) public view override returns ( bool upkeepNeeded,\r\n    bytes memory /* performData */  ) {\r\n        \r\n        for (uint i = 0; i < AllAccount.length; i++) {\r\n            for (uint j = 0; j < Meeting[AllAccount[i]].length; j++) {\r\n                if(Meeting[AllAccount[i]][j].time > 0 && Meeting[AllAccount[i]][j].completed == false){\r\n                    bool isOpen = XTELPState.OPEN == s_xtelpState[msg.sender];\r\n                    bool timePassed = ((block.timestamp - Meeting[AllAccount[i]][j].start) >  Meeting[AllAccount[i]][j].time);\r\n                    upkeepNeeded = (isOpen && timePassed);\r\n                }\r\n                \r\n            }\r\n        }\r\n       \r\n    }\r\n\r\n    /**\r\n     * @dev Once `checkUpkeep` is returning `true`, this function is called\r\n     */\r\n    function performUpkeep(bytes calldata /*performData*/) external override {\r\n\r\n        for (uint i = 0; i < AllAccount.length; i++) {\r\n            for (uint j = 0; j < Meeting[AllAccount[i]].length; j++) {\r\n               (bool upkeepNeeded, ) = checkUpkeep(\"\");\r\n                require(upkeepNeeded, \"Doesn't meet requirement for UpKeep\");\r\n                Meeting[AllAccount[i]][j].completed = true;\r\n                Meeting[AllAccount[i]][j].end = block.timestamp;\r\n                s_xtelpState[AllAccount[i]] = XTELPState.CLOSED;\r\n            }\r\n        }\r\n        \r\n        \r\n        \r\n    }\r\n   \r\n   \r\n    /** Getter Functions */\r\n\r\n    function meetingNum() public view returns (uint256) {\r\n        return meetingIndex;\r\n    }\r\n    \r\n    function campaignNum() public view returns (uint256) {\r\n        return campaignIndex;\r\n    }\r\n\r\n    function getMeeting(address _prof) public view returns (meeting [] memory) {\r\n        return Meeting[_prof];\r\n    }\r\n      \r\n\r\n    function getProfile(address userAdd) public view returns (profile memory) {\r\n        return UserProfile[userAdd];\r\n    }\r\n\r\n    function getAllAccount() public view returns (address [] memory) {\r\n        return AllAccount;\r\n    }\r\n\r\n    function getCampaign() public view returns (campaign [] memory) {\r\n        return Campaign;\r\n    }\r\n    \r\n   \r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}